'use strict';

Object.defineProperty(exports, '__esModule', {
	value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports['default'] = assertJsx;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _preactRenderToStringJsx = require('preact-render-to-string/jsx');

var _preactRenderToStringJsx2 = _interopRequireDefault(_preactRenderToStringJsx);

var _chai = require('chai');

/** Options for all assertions.
 *	@property {function} isJsx					A test to see if the given parameter is a JSX VNode. Defaults to checking for the existence of an __isVNode property
 */
var options = {
	/* If `false`, props with function values will be omitted from the comparison entirely */
	functions: true,
	/* If `false`, ignores function names and bound state, asserting only that the compared attributes are functions */
	functionNames: true
};

exports.options = options;
// options to pass to renderToString() when doing a deep comparison
var RENDER_OPTS = {
	sortAttributes: true
};

// options to pass to renderToString() when doing a shallow comparison
var SHALLOW_OPTS = _extends({}, RENDER_OPTS, {
	shallow: true
});

// for shallow comparisons, the "expected" value should NOT have high order components resolved at the root
var SHALLOW_OPTS_EXPECTED = _extends({}, SHALLOW_OPTS, {
	renderRootComponent: false
});

// for "includes" and "contains", pretty-print the diff but not the version that gets compared
var INCLUDE_RENDER_OPTS = _extends({}, RENDER_OPTS, {
	pretty: false
});

var SHALLOW_INCLUDE_OPTS = _extends({}, INCLUDE_RENDER_OPTS, {
	shallow: true
});

var SHALLOW_INCLUDE_OPTS_EXPECTED = _extends({}, SHALLOW_INCLUDE_OPTS, {
	renderRootComponent: false
});

// The options for 'equal' and 'equals' change depending on whether the deep flag has been set with .deep prop
var getEqualOpts = function getEqualOpts(obj) {
	return _chai.util.flag(obj, 'deep') ? [RENDER_OPTS] : [SHALLOW_OPTS, SHALLOW_OPTS_EXPECTED];
};

// The options for 'includes' and 'contains' change depending on whether 'shallow' flag has been set with .shallow prop
var getIncludeOpts = function getIncludeOpts(obj) {
	return _chai.util.flag(obj, 'shallow') ? [SHALLOW_INCLUDE_OPTS, SHALLOW_INCLUDE_OPTS_EXPECTED] : [INCLUDE_RENDER_OPTS, INCLUDE_RENDER_OPTS, RENDER_OPTS];
};

// create an assertion template string for the given action
var msg = function msg(act) {
	return 'expected #{act} to ' + act + ' #{exp}';
};

// assert that an object is JSX (or more correctly, a VNode)
var isJsx = function isJsx(obj) {
	return obj && (options.isJsx ? options.isJsx(obj) : obj.__isVNode || isVNode(obj));
};

// does it look like a vnode?
var isVNode = function isVNode(obj) {
	return obj.hasOwnProperty('nodeName') && obj.hasOwnProperty('attributes') && obj.hasOwnProperty('children') && obj.constructor.name === 'VNode';
};

// inject default options and invoke render with no context
var doRender = function doRender(jsx, opts) {
	return (0, _preactRenderToStringJsx2['default'])(jsx, null, _extends({
		functions: options.functions,
		functionNames: options.functionNames
	}, opts));
};

// inject a chai assertion if the values being tested are JSX VNodes
var ifJsx = function ifJsx(fn, opts, optsExpected, displayOpts) {
	return function (next) {
		return function (jsx) {
			var resolvedOpts = opts;
			if (typeof opts === 'function') {
				var _opts = opts(this);

				var _opts2 = _slicedToArray(_opts, 3);

				resolvedOpts = _opts2[0];
				optsExpected = _opts2[1];
				displayOpts = _opts2[2];
			}

			for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				args[_key - 1] = arguments[_key];
			}

			if (!isJsx(this._obj)) return next.call.apply(next, [this, jsx].concat(args));
			var actual = doRender(this._obj, resolvedOpts).trim();
			var expected = doRender(jsx, optsExpected || resolvedOpts).trim();
			var diffActual = displayOpts ? doRender(this._obj, displayOpts).trim() : actual;
			var diffExpected = displayOpts ? doRender(jsx, displayOpts).trim() : expected;
			return fn(this, { expected: expected, actual: actual, diffActual: diffActual, diffExpected: diffExpected, jsx: jsx });
		};
	};
};

// create a passthrough function
var through = function through(next) {
	return function () {
		for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			args[_key2] = arguments[_key2];
		}

		return next.call.apply(next, [this].concat(args));
	};
};

// assert that a String is equal to the given string
var equal = function equal(a, _ref) {
	var expected = _ref.expected;
	var actual = _ref.actual;
	var diffExpected = _ref.diffExpected;
	var diffActual = _ref.diffActual;
	return a.assert(actual === expected, msg('equal'), msg('not equal'), diffExpected, diffActual, true);
};

// assert that a String contains the given string
var include = function include(a, _ref2) {
	var expected = _ref2.expected;
	var actual = _ref2.actual;
	var diffExpected = _ref2.diffExpected;
	var diffActual = _ref2.diffActual;
	return a.assert(~actual.indexOf(expected), msg('include'), msg('not include'), diffExpected, diffActual, true);
};

/** Middleware: pass to `chai.use()` to add JSX assertion support. */

function assertJsx(_ref3) {
	var Assertion = _ref3.Assertion;

	if (Assertion.__assertJsxMounted === true) return;
	Assertion.__assertJsxMounted = true;

	Assertion.overwriteMethod('eql', ifJsx(equal, RENDER_OPTS));
	Assertion.overwriteMethod('eqls', ifJsx(equal, RENDER_OPTS));

	Assertion.overwriteMethod('equal', ifJsx(equal, getEqualOpts));
	Assertion.overwriteMethod('equals', ifJsx(equal, getEqualOpts));

	Assertion.addProperty('shallow', function () {
		_chai.util.flag(this, 'shallow', true);
	});

	Assertion.addProperty('jsx', function () {
		this.assert(isJsx(this._obj), 'expected #{this} to be jsx', 'expected #{this} to not be jsx');
	});

	['include', 'includes', 'contain', 'contains'].forEach(function (method) {
		Assertion.overwriteChainableMethod(method, ifJsx(include, getIncludeOpts), through);
	});
}

assertJsx.options = options;

// auto-mount if possible
if (typeof chai !== 'undefined' && chai.use) chai.use(assertJsx);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O3FCQWlHd0IsU0FBUzs7Ozt1Q0FqR2QsNkJBQTZCOzs7O29CQUM3QixNQUFNOzs7OztBQUtsQixJQUFNLE9BQU8sR0FBRzs7QUFFdEIsVUFBUyxFQUFFLElBQUk7O0FBRWYsY0FBYSxFQUFFLElBQUk7Q0FDbkIsQ0FBQzs7OztBQUdGLElBQU0sV0FBVyxHQUFHO0FBQ25CLGVBQWMsRUFBRSxJQUFJO0NBQ3BCLENBQUM7OztBQUdGLElBQU0sWUFBWSxnQkFDZCxXQUFXO0FBQ2QsUUFBTyxFQUFFLElBQUk7RUFDYixDQUFDOzs7QUFHRixJQUFNLHFCQUFxQixnQkFDdkIsWUFBWTtBQUNmLG9CQUFtQixFQUFFLEtBQUs7RUFDMUIsQ0FBQzs7O0FBR0YsSUFBTSxtQkFBbUIsZ0JBQ3JCLFdBQVc7QUFDZCxPQUFNLEVBQUUsS0FBSztFQUNiLENBQUM7O0FBRUYsSUFBTSxvQkFBb0IsZ0JBQ3RCLG1CQUFtQjtBQUN0QixRQUFPLEVBQUUsSUFBSTtFQUNiLENBQUM7O0FBRUYsSUFBTSw2QkFBNkIsZ0JBQy9CLG9CQUFvQjtBQUN2QixvQkFBbUIsRUFBRSxLQUFLO0VBQzFCLENBQUM7OztBQUdGLElBQUksWUFBWSxHQUFHLFNBQWYsWUFBWSxDQUFJLEdBQUcsRUFBSztBQUMzQixRQUFPLFdBQUssSUFBSSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFLHFCQUFxQixDQUFDLENBQUM7Q0FDdEYsQ0FBQzs7O0FBR0YsSUFBSSxjQUFjLEdBQUcsU0FBakIsY0FBYyxDQUFJLEdBQUcsRUFBSztBQUM3QixRQUFPLFdBQUssSUFBSSxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDLG9CQUFvQixFQUFFLDZCQUE2QixDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsRUFBRSxtQkFBbUIsRUFBRSxXQUFXLENBQUMsQ0FBQztDQUNuSixDQUFDOzs7QUFHRixJQUFJLEdBQUcsR0FBRyxTQUFOLEdBQUcsQ0FBRyxHQUFHO2dDQUEwQixHQUFHO0NBQVMsQ0FBQzs7O0FBR3BELElBQUksS0FBSyxHQUFHLFNBQVIsS0FBSyxDQUFHLEdBQUc7UUFBSSxHQUFHLEtBQUssT0FBTyxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFJLEdBQUcsQ0FBQyxTQUFTLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEFBQUM7Q0FBQSxDQUFDOzs7QUFHakcsSUFBSSxPQUFPLEdBQUcsU0FBVixPQUFPLENBQUcsR0FBRztRQUFJLEdBQUcsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLElBQUksR0FBRyxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsSUFBSSxHQUFHLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxXQUFXLENBQUMsSUFBSSxLQUFHLE9BQU87Q0FBQSxDQUFDOzs7QUFHNUosSUFBSSxRQUFRLEdBQUcsU0FBWCxRQUFRLENBQUksR0FBRyxFQUFFLElBQUk7UUFBSywwQ0FBTyxHQUFHLEVBQUUsSUFBSTtBQUM3QyxXQUFTLEVBQUUsT0FBTyxDQUFDLFNBQVM7QUFDNUIsZUFBYSxFQUFFLE9BQU8sQ0FBQyxhQUFhO0lBQ2pDLElBQUksRUFDTjtDQUFBLENBQUM7OztBQUdILElBQUksS0FBSyxHQUFHLFNBQVIsS0FBSyxDQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLFdBQVc7UUFBSyxVQUFBLElBQUk7U0FBSSxVQUFTLEdBQUcsRUFBVztBQUNuRixPQUFJLFlBQVksR0FBRyxJQUFJLENBQUM7QUFDeEIsT0FBSSxPQUFPLElBQUksS0FBSyxVQUFVLEVBQUU7Z0JBQ2MsSUFBSSxDQUFDLElBQUksQ0FBQzs7OztBQUFyRCxnQkFBWTtBQUFFLGdCQUFZO0FBQUUsZUFBVztJQUN6Qzs7cUNBSjRFLElBQUk7QUFBSixRQUFJOzs7QUFNakYsT0FBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsT0FBTyxJQUFJLENBQUMsSUFBSSxNQUFBLENBQVQsSUFBSSxHQUFNLElBQUksRUFBRSxHQUFHLFNBQUssSUFBSSxFQUFDLENBQUM7QUFDNUQsT0FBSSxNQUFNLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDdEQsT0FBSSxRQUFRLEdBQUcsUUFBUSxDQUFDLEdBQUcsRUFBRSxZQUFZLElBQUksWUFBWSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDbEUsT0FBSSxVQUFVLEdBQUcsV0FBVyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQztBQUNoRixPQUFJLFlBQVksR0FBRyxXQUFXLEdBQUcsUUFBUSxDQUFDLEdBQUcsRUFBRSxXQUFXLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxRQUFRLENBQUM7QUFDOUUsVUFBTyxFQUFFLENBQUMsSUFBSSxFQUFFLEVBQUUsUUFBUSxFQUFSLFFBQVEsRUFBRSxNQUFNLEVBQU4sTUFBTSxFQUFFLFVBQVUsRUFBVixVQUFVLEVBQUUsWUFBWSxFQUFaLFlBQVksRUFBRSxHQUFHLEVBQUgsR0FBRyxFQUFFLENBQUMsQ0FBQztHQUNyRTtFQUFBO0NBQUEsQ0FBQzs7O0FBR0YsSUFBSSxPQUFPLEdBQUcsU0FBVixPQUFPLENBQUcsSUFBSTtRQUFJLFlBQWtCO3FDQUFOLElBQUk7QUFBSixPQUFJOzs7QUFBSSxTQUFPLElBQUksQ0FBQyxJQUFJLE1BQUEsQ0FBVCxJQUFJLEdBQU0sSUFBSSxTQUFLLElBQUksRUFBQyxDQUFDO0VBQUU7Q0FBQSxDQUFDOzs7QUFHN0UsSUFBSSxLQUFLLEdBQUcsU0FBUixLQUFLLENBQUksQ0FBQyxFQUFFLElBQThDO0tBQTVDLFFBQVEsR0FBVixJQUE4QyxDQUE1QyxRQUFRO0tBQUUsTUFBTSxHQUFsQixJQUE4QyxDQUFsQyxNQUFNO0tBQUUsWUFBWSxHQUFoQyxJQUE4QyxDQUExQixZQUFZO0tBQUUsVUFBVSxHQUE1QyxJQUE4QyxDQUFaLFVBQVU7UUFBTyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sS0FBRyxRQUFRLEVBQUUsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFLEdBQUcsQ0FBQyxXQUFXLENBQUMsRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQztDQUFBLENBQUM7OztBQUcvSixJQUFJLE9BQU8sR0FBRyxTQUFWLE9BQU8sQ0FBSSxDQUFDLEVBQUUsS0FBOEM7S0FBNUMsUUFBUSxHQUFWLEtBQThDLENBQTVDLFFBQVE7S0FBRSxNQUFNLEdBQWxCLEtBQThDLENBQWxDLE1BQU07S0FBRSxZQUFZLEdBQWhDLEtBQThDLENBQTFCLFlBQVk7S0FBRSxVQUFVLEdBQTVDLEtBQThDLENBQVosVUFBVTtRQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUMsYUFBYSxDQUFDLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBRSxJQUFJLENBQUM7Q0FBQSxDQUFDOzs7O0FBRzlKLFNBQVMsU0FBUyxDQUFDLEtBQWEsRUFBRTtLQUFiLFNBQVMsR0FBWCxLQUFhLENBQVgsU0FBUzs7QUFDNUMsS0FBSSxTQUFTLENBQUMsa0JBQWtCLEtBQUcsSUFBSSxFQUFFLE9BQU87QUFDaEQsVUFBUyxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQzs7QUFFcEMsVUFBUyxDQUFDLGVBQWUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO0FBQzVELFVBQVMsQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQzs7QUFFN0QsVUFBUyxDQUFDLGVBQWUsQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLEtBQUssRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO0FBQy9ELFVBQVMsQ0FBQyxlQUFlLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQzs7QUFFaEUsVUFBUyxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsWUFBWTtBQUM1QyxhQUFLLElBQUksQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO0VBQ2pDLENBQUMsQ0FBQzs7QUFFSCxVQUFTLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRyxZQUFZO0FBQ3pDLE1BQUksQ0FBQyxNQUFNLENBQ1YsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFDaEIsNEJBQTRCLEVBQzVCLGdDQUFnQyxDQUFDLENBQUM7RUFDbkMsQ0FBQyxDQUFDOztBQUVILEVBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUMsT0FBTyxDQUFFLFVBQUEsTUFBTSxFQUFJO0FBQ2pFLFdBQVMsQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLE9BQU8sRUFBRSxjQUFjLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztFQUNwRixDQUFDLENBQUM7Q0FDSDs7QUFFRCxTQUFTLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQzs7O0FBRzVCLElBQUksT0FBTyxJQUFJLEtBQUcsV0FBVyxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCByZW5kZXIgZnJvbSAncHJlYWN0LXJlbmRlci10by1zdHJpbmcvanN4JztcbmltcG9ydCB7dXRpbH0gZnJvbSAnY2hhaSc7XG5cbi8qKiBPcHRpb25zIGZvciBhbGwgYXNzZXJ0aW9ucy5cbiAqXHRAcHJvcGVydHkge2Z1bmN0aW9ufSBpc0pzeFx0XHRcdFx0XHRBIHRlc3QgdG8gc2VlIGlmIHRoZSBnaXZlbiBwYXJhbWV0ZXIgaXMgYSBKU1ggVk5vZGUuIERlZmF1bHRzIHRvIGNoZWNraW5nIGZvciB0aGUgZXhpc3RlbmNlIG9mIGFuIF9faXNWTm9kZSBwcm9wZXJ0eVxuICovXG5leHBvcnQgY29uc3Qgb3B0aW9ucyA9IHtcblx0LyogSWYgYGZhbHNlYCwgcHJvcHMgd2l0aCBmdW5jdGlvbiB2YWx1ZXMgd2lsbCBiZSBvbWl0dGVkIGZyb20gdGhlIGNvbXBhcmlzb24gZW50aXJlbHkgKi9cblx0ZnVuY3Rpb25zOiB0cnVlLFxuXHQvKiBJZiBgZmFsc2VgLCBpZ25vcmVzIGZ1bmN0aW9uIG5hbWVzIGFuZCBib3VuZCBzdGF0ZSwgYXNzZXJ0aW5nIG9ubHkgdGhhdCB0aGUgY29tcGFyZWQgYXR0cmlidXRlcyBhcmUgZnVuY3Rpb25zICovXG5cdGZ1bmN0aW9uTmFtZXM6IHRydWVcbn07XG5cbi8vIG9wdGlvbnMgdG8gcGFzcyB0byByZW5kZXJUb1N0cmluZygpIHdoZW4gZG9pbmcgYSBkZWVwIGNvbXBhcmlzb25cbmNvbnN0IFJFTkRFUl9PUFRTID0ge1xuXHRzb3J0QXR0cmlidXRlczogdHJ1ZVxufTtcblxuLy8gb3B0aW9ucyB0byBwYXNzIHRvIHJlbmRlclRvU3RyaW5nKCkgd2hlbiBkb2luZyBhIHNoYWxsb3cgY29tcGFyaXNvblxuY29uc3QgU0hBTExPV19PUFRTID0ge1xuXHQuLi5SRU5ERVJfT1BUUyxcblx0c2hhbGxvdzogdHJ1ZVxufTtcblxuLy8gZm9yIHNoYWxsb3cgY29tcGFyaXNvbnMsIHRoZSBcImV4cGVjdGVkXCIgdmFsdWUgc2hvdWxkIE5PVCBoYXZlIGhpZ2ggb3JkZXIgY29tcG9uZW50cyByZXNvbHZlZCBhdCB0aGUgcm9vdFxuY29uc3QgU0hBTExPV19PUFRTX0VYUEVDVEVEID0ge1xuXHQuLi5TSEFMTE9XX09QVFMsXG5cdHJlbmRlclJvb3RDb21wb25lbnQ6IGZhbHNlXG59O1xuXG4vLyBmb3IgXCJpbmNsdWRlc1wiIGFuZCBcImNvbnRhaW5zXCIsIHByZXR0eS1wcmludCB0aGUgZGlmZiBidXQgbm90IHRoZSB2ZXJzaW9uIHRoYXQgZ2V0cyBjb21wYXJlZFxuY29uc3QgSU5DTFVERV9SRU5ERVJfT1BUUyA9IHtcblx0Li4uUkVOREVSX09QVFMsXG5cdHByZXR0eTogZmFsc2Vcbn07XG5cbmNvbnN0IFNIQUxMT1dfSU5DTFVERV9PUFRTID0ge1xuXHQuLi5JTkNMVURFX1JFTkRFUl9PUFRTLFxuXHRzaGFsbG93OiB0cnVlXG59O1xuXG5jb25zdCBTSEFMTE9XX0lOQ0xVREVfT1BUU19FWFBFQ1RFRCA9IHtcblx0Li4uU0hBTExPV19JTkNMVURFX09QVFMsXG5cdHJlbmRlclJvb3RDb21wb25lbnQ6IGZhbHNlXG59O1xuXG4vLyBUaGUgb3B0aW9ucyBmb3IgJ2VxdWFsJyBhbmQgJ2VxdWFscycgY2hhbmdlIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBkZWVwIGZsYWcgaGFzIGJlZW4gc2V0IHdpdGggLmRlZXAgcHJvcFxubGV0IGdldEVxdWFsT3B0cyA9IChvYmopID0+IHtcblx0cmV0dXJuIHV0aWwuZmxhZyhvYmosICdkZWVwJykgPyBbUkVOREVSX09QVFNdIDogW1NIQUxMT1dfT1BUUywgU0hBTExPV19PUFRTX0VYUEVDVEVEXTtcbn07XG5cbi8vIFRoZSBvcHRpb25zIGZvciAnaW5jbHVkZXMnIGFuZCAnY29udGFpbnMnIGNoYW5nZSBkZXBlbmRpbmcgb24gd2hldGhlciAnc2hhbGxvdycgZmxhZyBoYXMgYmVlbiBzZXQgd2l0aCAuc2hhbGxvdyBwcm9wXG5sZXQgZ2V0SW5jbHVkZU9wdHMgPSAob2JqKSA9PiB7XG5cdHJldHVybiB1dGlsLmZsYWcob2JqLCAnc2hhbGxvdycpID8gW1NIQUxMT1dfSU5DTFVERV9PUFRTLCBTSEFMTE9XX0lOQ0xVREVfT1BUU19FWFBFQ1RFRF0gOiBbSU5DTFVERV9SRU5ERVJfT1BUUywgSU5DTFVERV9SRU5ERVJfT1BUUywgUkVOREVSX09QVFNdO1xufTtcblxuLy8gY3JlYXRlIGFuIGFzc2VydGlvbiB0ZW1wbGF0ZSBzdHJpbmcgZm9yIHRoZSBnaXZlbiBhY3Rpb25cbmxldCBtc2cgPSBhY3QgPT4gYGV4cGVjdGVkICN7YWN0fSB0byAke2FjdH0gI3tleHB9YDtcblxuLy8gYXNzZXJ0IHRoYXQgYW4gb2JqZWN0IGlzIEpTWCAob3IgbW9yZSBjb3JyZWN0bHksIGEgVk5vZGUpXG5sZXQgaXNKc3ggPSBvYmogPT4gb2JqICYmIChvcHRpb25zLmlzSnN4ID8gb3B0aW9ucy5pc0pzeChvYmopIDogKG9iai5fX2lzVk5vZGUgfHwgaXNWTm9kZShvYmopKSk7XG5cbi8vIGRvZXMgaXQgbG9vayBsaWtlIGEgdm5vZGU/XG5sZXQgaXNWTm9kZSA9IG9iaiA9PiBvYmouaGFzT3duUHJvcGVydHkoJ25vZGVOYW1lJykgJiYgb2JqLmhhc093blByb3BlcnR5KCdhdHRyaWJ1dGVzJykgJiYgb2JqLmhhc093blByb3BlcnR5KCdjaGlsZHJlbicpICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lPT09J1ZOb2RlJztcblxuLy8gaW5qZWN0IGRlZmF1bHQgb3B0aW9ucyBhbmQgaW52b2tlIHJlbmRlciB3aXRoIG5vIGNvbnRleHRcbmxldCBkb1JlbmRlciA9IChqc3gsIG9wdHMpID0+IHJlbmRlcihqc3gsIG51bGwsIHtcblx0ZnVuY3Rpb25zOiBvcHRpb25zLmZ1bmN0aW9ucyxcblx0ZnVuY3Rpb25OYW1lczogb3B0aW9ucy5mdW5jdGlvbk5hbWVzLFxuXHQuLi5vcHRzXG59KTtcblxuLy8gaW5qZWN0IGEgY2hhaSBhc3NlcnRpb24gaWYgdGhlIHZhbHVlcyBiZWluZyB0ZXN0ZWQgYXJlIEpTWCBWTm9kZXNcbmxldCBpZkpzeCA9IChmbiwgb3B0cywgb3B0c0V4cGVjdGVkLCBkaXNwbGF5T3B0cykgPT4gbmV4dCA9PiBmdW5jdGlvbihqc3gsIC4uLmFyZ3MpIHtcblx0bGV0IHJlc29sdmVkT3B0cyA9IG9wdHM7XG5cdGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdChbcmVzb2x2ZWRPcHRzLCBvcHRzRXhwZWN0ZWQsIGRpc3BsYXlPcHRzXSA9IG9wdHModGhpcykpO1xuXHR9XG5cblx0aWYgKCFpc0pzeCh0aGlzLl9vYmopKSByZXR1cm4gbmV4dC5jYWxsKHRoaXMsIGpzeCwgLi4uYXJncyk7XG5cdGxldCBhY3R1YWwgPSBkb1JlbmRlcih0aGlzLl9vYmosIHJlc29sdmVkT3B0cykudHJpbSgpO1xuXHRsZXQgZXhwZWN0ZWQgPSBkb1JlbmRlcihqc3gsIG9wdHNFeHBlY3RlZCB8fCByZXNvbHZlZE9wdHMpLnRyaW0oKTtcblx0bGV0IGRpZmZBY3R1YWwgPSBkaXNwbGF5T3B0cyA/IGRvUmVuZGVyKHRoaXMuX29iaiwgZGlzcGxheU9wdHMpLnRyaW0oKSA6IGFjdHVhbDtcblx0bGV0IGRpZmZFeHBlY3RlZCA9IGRpc3BsYXlPcHRzID8gZG9SZW5kZXIoanN4LCBkaXNwbGF5T3B0cykudHJpbSgpIDogZXhwZWN0ZWQ7XG5cdHJldHVybiBmbih0aGlzLCB7IGV4cGVjdGVkLCBhY3R1YWwsIGRpZmZBY3R1YWwsIGRpZmZFeHBlY3RlZCwganN4IH0pO1xufTtcblxuLy8gY3JlYXRlIGEgcGFzc3Rocm91Z2ggZnVuY3Rpb25cbmxldCB0aHJvdWdoID0gbmV4dCA9PiBmdW5jdGlvbiguLi5hcmdzKSB7IHJldHVybiBuZXh0LmNhbGwodGhpcywgLi4uYXJncyk7IH07XG5cbi8vIGFzc2VydCB0aGF0IGEgU3RyaW5nIGlzIGVxdWFsIHRvIHRoZSBnaXZlbiBzdHJpbmdcbmxldCBlcXVhbCA9IChhLCB7IGV4cGVjdGVkLCBhY3R1YWwsIGRpZmZFeHBlY3RlZCwgZGlmZkFjdHVhbCB9KSA9PiBhLmFzc2VydChhY3R1YWw9PT1leHBlY3RlZCwgbXNnKCdlcXVhbCcpLCBtc2coJ25vdCBlcXVhbCcpLCBkaWZmRXhwZWN0ZWQsIGRpZmZBY3R1YWwsIHRydWUpO1xuXG4vLyBhc3NlcnQgdGhhdCBhIFN0cmluZyBjb250YWlucyB0aGUgZ2l2ZW4gc3RyaW5nXG5sZXQgaW5jbHVkZSA9IChhLCB7IGV4cGVjdGVkLCBhY3R1YWwsIGRpZmZFeHBlY3RlZCwgZGlmZkFjdHVhbCB9KSA9PiBhLmFzc2VydCh+YWN0dWFsLmluZGV4T2YoZXhwZWN0ZWQpLCBtc2coJ2luY2x1ZGUnKSwgbXNnKCdub3QgaW5jbHVkZScpLCBkaWZmRXhwZWN0ZWQsIGRpZmZBY3R1YWwsIHRydWUpO1xuXG4vKiogTWlkZGxld2FyZTogcGFzcyB0byBgY2hhaS51c2UoKWAgdG8gYWRkIEpTWCBhc3NlcnRpb24gc3VwcG9ydC4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFzc2VydEpzeCh7IEFzc2VydGlvbiB9KSB7XG5cdGlmIChBc3NlcnRpb24uX19hc3NlcnRKc3hNb3VudGVkPT09dHJ1ZSkgcmV0dXJuO1xuXHRBc3NlcnRpb24uX19hc3NlcnRKc3hNb3VudGVkID0gdHJ1ZTtcblxuXHRBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdlcWwnLCBpZkpzeChlcXVhbCwgUkVOREVSX09QVFMpKTtcblx0QXNzZXJ0aW9uLm92ZXJ3cml0ZU1ldGhvZCgnZXFscycsIGlmSnN4KGVxdWFsLCBSRU5ERVJfT1BUUykpO1xuXG5cdEFzc2VydGlvbi5vdmVyd3JpdGVNZXRob2QoJ2VxdWFsJywgaWZKc3goZXF1YWwsIGdldEVxdWFsT3B0cykpO1xuXHRBc3NlcnRpb24ub3ZlcndyaXRlTWV0aG9kKCdlcXVhbHMnLCBpZkpzeChlcXVhbCwgZ2V0RXF1YWxPcHRzKSk7XG5cblx0QXNzZXJ0aW9uLmFkZFByb3BlcnR5KCdzaGFsbG93JywgZnVuY3Rpb24gKCkge1xuXHRcdHV0aWwuZmxhZyh0aGlzLCAnc2hhbGxvdycsIHRydWUpO1xuXHR9KTtcblxuXHRBc3NlcnRpb24uYWRkUHJvcGVydHkoJ2pzeCcsICBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5hc3NlcnQoXG5cdFx0XHRpc0pzeCh0aGlzLl9vYmopLFxuXHRcdFx0J2V4cGVjdGVkICN7dGhpc30gdG8gYmUganN4Jyxcblx0XHRcdCdleHBlY3RlZCAje3RoaXN9IHRvIG5vdCBiZSBqc3gnKTtcblx0fSk7XG5cblx0WydpbmNsdWRlJywgJ2luY2x1ZGVzJywgJ2NvbnRhaW4nLCAnY29udGFpbnMnXS5mb3JFYWNoKCBtZXRob2QgPT4ge1xuXHRcdEFzc2VydGlvbi5vdmVyd3JpdGVDaGFpbmFibGVNZXRob2QobWV0aG9kLCBpZkpzeChpbmNsdWRlLCBnZXRJbmNsdWRlT3B0cyksIHRocm91Z2gpO1xuXHR9KTtcbn1cblxuYXNzZXJ0SnN4Lm9wdGlvbnMgPSBvcHRpb25zO1xuXG4vLyBhdXRvLW1vdW50IGlmIHBvc3NpYmxlXG5pZiAodHlwZW9mIGNoYWkhPT0ndW5kZWZpbmVkJyAmJiBjaGFpLnVzZSkgY2hhaS51c2UoYXNzZXJ0SnN4KTtcbiJdfQ==